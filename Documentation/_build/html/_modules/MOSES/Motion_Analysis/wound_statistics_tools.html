

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>MOSES.Motion_Analysis.wound_statistics_tools &mdash; MOSES  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> MOSES
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../MOSES.html">MOSES package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MOSES</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>MOSES.Motion_Analysis.wound_statistics_tools</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for MOSES.Motion_Analysis.wound_statistics_tools</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Thu Sep 27 22:04:57 2018</span>

<span class="sd">@author: felix</span>

<span class="sd">set of tools for describing the wound boundary of wound healing assays. </span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 

<span class="c1"># =============================================================================</span>
<span class="c1">#   Wound Finding Tools</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># option 1: detect boundary edges by image segmentation. </span>
<div class="viewcode-block" id="detect_edges_rgb"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.detect_edges_rgb">[docs]</a><span class="k">def</span> <span class="nf">detect_edges_rgb</span><span class="p">(</span> <span class="n">img_r</span><span class="p">,</span> <span class="n">img_g</span><span class="p">,</span> <span class="n">downscale</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="k">import</span> <span class="n">gaussian</span> 
    <span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="k">import</span> <span class="n">canny</span> 
    <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="k">import</span> <span class="n">label</span> 
    <span class="kn">from</span> <span class="nn">skimage.exposure</span> <span class="k">import</span> <span class="n">rescale_intensity</span><span class="p">,</span> <span class="n">equalize_hist</span>
    <span class="kn">from</span> <span class="nn">skimage.filters.rank</span> <span class="k">import</span> <span class="n">median</span>
    <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">square</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">img_r</span><span class="p">,</span> <span class="n">img_g</span><span class="p">])</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">maxpool_scale</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">downscale</span><span class="p">)</span>
    
    <span class="n">img_r</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">255.</span> <span class="p">;</span> <span class="n">img_g</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">255.</span>
    <span class="n">img_r</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">img_r</span><span class="p">)</span>
    <span class="n">img_g</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">img_g</span><span class="p">)</span>
   
    <span class="c1"># implement smoothing to suppress noise. </span>
    <span class="c1"># consider switching to using anisotropic filtering? </span>
    <span class="n">img_r</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">img_r</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>  
    <span class="n">img_g</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">img_g</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>
    
    <span class="n">img_r_</span> <span class="o">=</span> <span class="n">img_r</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">img_g_</span> <span class="o">=</span> <span class="n">img_g</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># use Canny filter to locate edges.     </span>
    <span class="n">edges_r</span> <span class="o">=</span> <span class="n">canny</span><span class="p">(</span><span class="n">img_r</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span> <span class="p">;</span> <span class="n">edges_g</span> <span class="o">=</span> <span class="n">canny</span><span class="p">(</span><span class="n">img_g</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    
    <span class="n">labelled_r</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">edges_r</span><span class="p">)</span>
    <span class="n">labelled_g</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">edges_g</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">labelled_r</span><span class="p">,</span> <span class="n">labelled_g</span><span class="p">,</span> <span class="n">img_r_</span><span class="p">,</span> <span class="n">img_g_</span></div>
    

<div class="viewcode-block" id="detect_edges_gray"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.detect_edges_gray">[docs]</a><span class="k">def</span> <span class="nf">detect_edges_gray</span><span class="p">(</span> <span class="n">img</span><span class="p">,</span> <span class="n">downscale</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="k">import</span> <span class="n">gaussian</span> 
    <span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="k">import</span> <span class="n">canny</span> 
    <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="k">import</span> <span class="n">label</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">Utility_Functions.image</span> <span class="k">import</span> <span class="n">maxpool_scale</span>
    
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">img</span><span class="p">,</span> <span class="n">img</span><span class="p">])</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">maxpool_scale</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">downscale</span><span class="p">)</span>
    
    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">255.</span> 
    <span class="n">img</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span> 
    <span class="n">edges</span> <span class="o">=</span> <span class="n">canny</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span> 
    <span class="n">labelled</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="c1"># technically should rescale back... </span>
    
    <span class="k">return</span> <span class="n">labelled</span></div>
    
<span class="c1"># use this function to preserve continuity in the detected wound boundary edges!.  </span>
<div class="viewcode-block" id="filter_edges"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.filter_edges">[docs]</a><span class="k">def</span> <span class="nf">filter_edges</span><span class="p">(</span><span class="n">labelled_edges</span><span class="p">,</span> <span class="n">seed_img</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># return the closest to the centre, if no seed. </span>
    <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="k">import</span> <span class="n">regionprops</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="k">import</span> <span class="n">match_template</span>
    
    <span class="n">uniq_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labelled_edges</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">regs</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">labelled_edges</span><span class="p">)</span>

    <span class="n">line_centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># derive the centroid coordinate. </span>
    <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="n">regs</span><span class="p">:</span>
        <span class="n">centre</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">centroid</span>
        <span class="n">line_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centre</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># put in x,y coords? </span>
    
    <span class="n">line_centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">line_centroids</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">seed_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># choose that which is closest to the seed by cross-correlating the masks</span>
        <span class="n">xcorr_masks</span> <span class="o">=</span> <span class="p">[]</span>    
        <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">uniq_labels</span><span class="p">:</span>
            <span class="n">test_mask</span> <span class="o">=</span> <span class="n">labelled_edges</span><span class="o">==</span><span class="n">lab</span>
            <span class="n">ref_mask</span> <span class="o">=</span> <span class="n">seed_img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="n">xcorr_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">match_template</span><span class="p">(</span><span class="n">ref_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">),</span><span class="n">test_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">labelled_edges</span> <span class="o">==</span> <span class="n">uniq_labels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">xcorr_masks</span><span class="p">)]</span>    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">labelled_edges</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">centre_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">n</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">m</span><span class="o">/</span><span class="mf">2.</span><span class="p">])</span>
        <span class="n">dists_centre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">line_centroids</span> <span class="o">-</span> <span class="n">centre_img</span><span class="p">[</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">labelled_edges</span> <span class="o">==</span> <span class="n">uniq_labels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists_centre</span><span class="p">)]</span></div>
            
        
<span class="c1"># utility function to match the nearest neighbour pairs between spixel points. </span>
<div class="viewcode-block" id="find_all_epsilon_pairs"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.find_all_epsilon_pairs">[docs]</a><span class="k">def</span> <span class="nf">find_all_epsilon_pairs</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">,</span> <span class="n">nearest_N</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="n">select2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dist_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    
    <span class="n">selected_ids</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">select2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">test</span><span class="o">&gt;=</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">test</span><span class="o">&lt;=</span><span class="n">max_dist</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">select2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">test</span><span class="p">)[:</span><span class="n">nearest_N</span><span class="p">]]</span>
            <span class="n">selected_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)),</span> <span class="n">match</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">selected_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">selected_ids</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">selected_ids</span></div>
    
    
<div class="viewcode-block" id="generate_pair_distances"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.generate_pair_distances">[docs]</a><span class="k">def</span> <span class="nf">generate_pair_distances</span><span class="p">(</span><span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span><span class="p">,</span> <span class="n">inf_distance</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="k">import</span> <span class="n">pairwise_distances</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    
    <span class="n">sim_r</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">coords_r</span><span class="p">)</span>
    <span class="n">sim_g</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">coords_g</span><span class="p">)</span>
    
    <span class="c1"># make self-connections invalid. </span>
    <span class="n">sim_r</span> <span class="o">=</span> <span class="n">sim_r</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inf_distance</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sim_r</span><span class="p">)))</span>
    <span class="n">sim_g</span> <span class="o">=</span> <span class="n">sim_g</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inf_distance</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sim_g</span><span class="p">)))</span>
    
    <span class="k">return</span> <span class="n">sim_r</span><span class="p">,</span> <span class="n">sim_g</span></div>
    
    
<div class="viewcode-block" id="remove_singletons"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.remove_singletons">[docs]</a><span class="k">def</span> <span class="nf">remove_singletons</span><span class="p">(</span><span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span><span class="p">,</span> <span class="n">dist_thresh</span><span class="p">,</span> <span class="n">inf_distance</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">min_no</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="n">p_r</span><span class="p">,</span> <span class="n">p_g</span> <span class="o">=</span> <span class="n">generate_pair_distances</span><span class="p">(</span><span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span><span class="p">,</span> <span class="n">inf_distance</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
    
<span class="c1">#    select_r = np.min(p_r, axis=1) &lt;= dist_thresh</span>
<span class="c1">#    select_g = np.min(p_g, axis=1) &lt;= dist_thresh</span>
    <span class="n">select_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p_r</span><span class="o">&lt;=</span><span class="n">dist_thresh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_no</span>
    <span class="n">select_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p_g</span><span class="o">&lt;=</span><span class="n">dist_thresh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_no</span>

    <span class="k">return</span> <span class="n">coords_r</span><span class="p">[</span><span class="n">select_r</span><span class="p">],</span> <span class="n">coords_g</span><span class="p">[</span><span class="n">select_g</span><span class="p">]</span></div>
    
    
<div class="viewcode-block" id="sample_and_match_red_green_segs"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.sample_and_match_red_green_segs">[docs]</a><span class="k">def</span> <span class="nf">sample_and_match_red_green_segs</span><span class="p">(</span><span class="n">red_mask</span><span class="p">,</span> <span class="n">green_mask</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dist_thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nearest_N</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="k">import</span> <span class="n">pairwise_distances</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span> <span class="o">=</span> <span class="n">red_mask</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ncols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nrows</span><span class="p">))</span>
    
    <span class="n">x_r</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">red_mask</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">y_r</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">red_mask</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="n">x_g</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">green_mask</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">y_g</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">green_mask</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="c1"># now sample... </span>
    <span class="n">select_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_r</span><span class="p">))</span>
    <span class="n">select_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_g</span><span class="p">))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">select_r</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">select_g</span><span class="p">)</span>
    
    <span class="n">x_r_</span> <span class="o">=</span> <span class="n">x_r</span><span class="p">[</span><span class="n">select_r</span><span class="p">[:</span><span class="n">n_samples</span><span class="p">]]</span>
    <span class="n">y_r_</span> <span class="o">=</span> <span class="n">y_r</span><span class="p">[</span><span class="n">select_r</span><span class="p">[:</span><span class="n">n_samples</span><span class="p">]]</span>
    <span class="n">x_g_</span> <span class="o">=</span> <span class="n">x_g</span><span class="p">[</span><span class="n">select_g</span><span class="p">[:</span><span class="n">n_samples</span><span class="p">]]</span>
    <span class="n">y_g_</span> <span class="o">=</span> <span class="n">y_g</span><span class="p">[</span><span class="n">select_g</span><span class="p">[:</span><span class="n">n_samples</span><span class="p">]]</span>


    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_r_</span><span class="p">,</span> <span class="n">y_r_</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_g_</span><span class="p">,</span> <span class="n">y_g_</span><span class="p">,</span> <span class="s1">&#39;go&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="n">nrows</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">ncols</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the pairwise distances between R and G points </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x_r_</span><span class="p">,</span> <span class="n">y_r_</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">coords_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x_g_</span><span class="p">,</span> <span class="n">y_g_</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove Singletons </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span> <span class="o">=</span> <span class="n">remove_singletons</span><span class="p">(</span><span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="n">dist_thresh</span><span class="p">,</span> <span class="n">inf_distance</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">nrows</span><span class="p">,</span><span class="n">ncols</span><span class="p">]))</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span><span class="p">)</span>
    <span class="n">valid_pairs</span> <span class="o">=</span> <span class="n">find_all_epsilon_pairs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">dist_thresh</span><span class="o">=</span><span class="n">dist_thresh</span><span class="p">,</span> <span class="n">nearest_N</span><span class="o">=</span><span class="n">nearest_N</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    stack together valid pairs and filter for unique</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
<span class="c1">#        print valid_pairs.shape</span>
        <span class="n">unique_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">valid_pairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span> <span class="c1"># filter for the unique r and g coords</span>
        <span class="n">unique_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">valid_pairs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="c1"># graph for checking . </span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coords_r</span><span class="p">[</span><span class="n">unique_r</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords_r</span><span class="p">[</span><span class="n">unique_r</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coords_g</span><span class="p">[</span><span class="n">unique_g</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords_g</span><span class="p">[</span><span class="n">unique_g</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;go&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="n">nrows</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">ncols</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            
        <span class="k">return</span> <span class="n">coords_r</span><span class="p">[</span><span class="n">unique_r</span><span class="p">],</span> <span class="n">coords_g</span><span class="p">[</span><span class="n">unique_g</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="match_red_green_segs"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.match_red_green_segs">[docs]</a><span class="k">def</span> <span class="nf">match_red_green_segs</span><span class="p">(</span><span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nearest_N</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="k">import</span> <span class="n">pairwise_distances</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">nrows</span><span class="p">,</span><span class="n">ncols</span> <span class="o">=</span> <span class="n">shape</span>
    
    <span class="n">p</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span><span class="p">)</span>
    <span class="n">valid_pairs</span> <span class="o">=</span> <span class="n">find_all_epsilon_pairs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="n">max_dist</span><span class="p">,</span> <span class="n">nearest_N</span><span class="o">=</span><span class="n">nearest_N</span><span class="p">)</span>
    
    <span class="c1"># filter for uniques. </span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
        
        <span class="n">unique_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">valid_pairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span> <span class="c1"># filter for the unique r and g coords</span>
        <span class="n">unique_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">valid_pairs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">coords_r</span><span class="p">[</span><span class="n">unique_r</span><span class="p">],</span> <span class="n">coords_g</span><span class="p">[</span><span class="n">unique_g</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="eval_boundary_coords"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.eval_boundary_coords">[docs]</a><span class="k">def</span> <span class="nf">eval_boundary_coords</span><span class="p">(</span><span class="n">spl</span><span class="p">,</span> <span class="n">yline</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    spl: spline model for the boundary coords. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">xline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">spl</span><span class="p">,</span> <span class="n">yline</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">xline</span><span class="p">,</span> <span class="n">yline</span><span class="p">])</span><span class="o">.</span><span class="n">T</span></div>
    
    
<span class="c1"># not actually sure what this does? </span>
<div class="viewcode-block" id="find_stable_wound_frame"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.find_stable_wound_frame">[docs]</a><span class="k">def</span> <span class="nf">find_stable_wound_frame</span><span class="p">(</span><span class="n">coefs_time</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coefs_time</span><span class="p">))</span>
    <span class="n">curve_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">coefs_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="n">all_good_times</span> <span class="o">=</span> <span class="n">select</span><span class="p">[</span><span class="n">curve_valid</span><span class="p">]</span>

    <span class="n">stretches</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="c1"># group into consecutive regions. </span>
    <span class="n">stretch</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_good_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># add this in already. </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_good_times</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">time0</span> <span class="o">=</span> <span class="n">all_good_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">time1</span> <span class="o">=</span> <span class="n">all_good_times</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">time1</span> <span class="o">-</span> <span class="n">time0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">stretch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time1</span><span class="p">)</span>
            <span class="c1"># last time whatever happens we append. </span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_good_times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">stretches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stretch</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stretches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stretch</span><span class="p">)</span>
            <span class="n">stretch</span><span class="o">=</span><span class="p">[]</span>

    <span class="c1"># count the lengths and if satisfies min length criteria take the first frame.</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stretches</span><span class="p">:</span>
        <span class="n">len_stretch</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">len_stretch</span> <span class="o">&gt;=</span> <span class="n">min_length</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span></div>


<div class="viewcode-block" id="stack_curves"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.stack_curves">[docs]</a><span class="k">def</span> <span class="nf">stack_curves</span><span class="p">(</span><span class="n">curves</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">])</span>
    <span class="n">select</span> <span class="o">=</span> <span class="n">lens</span><span class="p">[</span><span class="n">lens</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="c1"># there is nothing.</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">curves</span><span class="p">),</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">lines</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># nothing. </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">lens</span><span class="p">[</span><span class="n">lens</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">min_len</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">[:</span><span class="n">min_len</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_boundary_lines"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.find_boundary_lines">[docs]</a><span class="k">def</span> <span class="nf">find_boundary_lines</span><span class="p">(</span><span class="n">boundary_curves</span><span class="p">,</span> <span class="n">yline</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundary_curves</span><span class="p">)):</span>
        <span class="n">spl_curve</span> <span class="o">=</span> <span class="n">boundary_curves</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spl_curve</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">yline</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b_curve</span> <span class="o">=</span> <span class="n">eval_boundary_coords</span><span class="p">(</span><span class="n">spl_curve</span><span class="p">,</span> <span class="n">yline</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_curve</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># only store the x coordinates. </span>
            
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<span class="c1">#==============================================================================</span>
<span class="c1">#   Cleaning up tools.</span>
<span class="c1">#==============================================================================</span>
<div class="viewcode-block" id="outlier_detect_axis"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.outlier_detect_axis">[docs]</a><span class="k">def</span> <span class="nf">outlier_detect_axis</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#    from scipy.stats import iqr</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span><span class="n">axis</span><span class="p">]</span> <span class="c1"># which of the coordinates will we use?</span>

    <span class="n">thresh_lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">thresh</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">thresh_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">thresh</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="n">inlier_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">thresh_lower</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">thresh_upper</span><span class="p">)</span> <span class="c1"># standard gaussian type fitting.</span>
    <span class="k">return</span> <span class="n">inlier_vals</span></div>
            
    
<div class="viewcode-block" id="outlier_detect_graph"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.outlier_detect_graph">[docs]</a><span class="k">def</span> <span class="nf">outlier_detect_graph</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Outlier point detection based on &#39;communities&#39;</span>
<span class="sd">    # how can this be further optimized? </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span> 
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="k">import</span> <span class="n">pairwise_distances</span>
    
    <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">nx_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy_matrix</span><span class="p">(</span><span class="n">adj_matrix</span><span class="o">&lt;=</span><span class="n">thresh</span><span class="p">)</span>
    
    <span class="c1"># get the connected components and sort by the largest connected... </span>
    <span class="n">cnn</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">nx_graph</span><span class="p">),</span> <span class="n">key</span> <span class="o">=</span> <span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># largest first.</span>

    <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cnn</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span></div>

<span class="c1"># test with weighted polyfit?</span>
<span class="c1"># this was initially a test to see if we can play with the number of points but meh...    </span>
<span class="c1">#def fit_polyfit(x,y, max_x, bins=50, n_points=4, degree=5):</span>
<span class="c1">#    </span>
<span class="c1">#    from scipy.interpolate import UnivariateSpline</span>
<span class="c1">#    </span>
<span class="c1">#    # here we will fit a polynomial and use a robust fitting algorithm based on weighting the distance. naively we will first do this using equal binning.  </span>
<span class="c1">#    weights_x = np.zeros(len(x))</span>
<span class="c1">#    </span>
<span class="c1">#    xbins = np.linspace(0, max_x, bins+1)</span>
<span class="c1">#    </span>
<span class="c1">#    for i in range(bins):</span>
<span class="c1">#        x1 = xbins[i]</span>
<span class="c1">#        x2 = xbins[i+1]</span>
<span class="c1">#</span>
<span class="c1">#        select_x = np.logical_and(x&gt;=x1, x&lt;x2)</span>
<span class="c1">#        if np.sum(select_x) &gt; 0: </span>
<span class="c1">##            weights_x[select_x] = 1./np.abs(np.sum(select_x)-n_points) # maximum weight if there is only one value? hm... thats not good either... </span>
<span class="c1">#            weights_x[select_x] = np.sum(select_x)</span>
<span class="c1">#    # we deal with outlier detection. by findiing components not close. </span>
<span class="c1">##    p = np.polyfit(y,x, deg=degree, w=weights_x) #use the weights ... </span>
<span class="c1">#    p = np.polyfit(y,x, deg=degree)</span>
<span class="c1">#    </span>
<span class="c1">#    return p</span>
    
<div class="viewcode-block" id="fit_polyfit"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.fit_polyfit">[docs]</a><span class="k">def</span> <span class="nf">fit_polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">p</span></div>


<div class="viewcode-block" id="test_y_density"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.test_y_density">[docs]</a><span class="k">def</span> <span class="nf">test_y_density</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">frac_thresh</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
   <span class="n">y_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">bins</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
   
   <span class="n">y_pos</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
   <span class="n">counts</span> <span class="o">=</span> <span class="p">[]</span>

   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
       <span class="n">y1</span> <span class="o">=</span> <span class="n">y_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
       <span class="n">y2</span> <span class="o">=</span> <span class="n">y_bins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

       <span class="n">select_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">y_pos</span><span class="o">&gt;=</span><span class="n">y1</span><span class="p">,</span> <span class="n">y_pos</span><span class="o">&lt;</span><span class="n">y2</span><span class="p">)</span>
       <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">select_</span><span class="p">)</span>
       <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
       
   <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
   <span class="n">y_frac_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">))</span>
       
   <span class="k">return</span> <span class="n">y_frac_</span> <span class="o">&gt;</span> <span class="n">frac_thresh</span></div>
    
<span class="c1"># do we have duplicates here of this function?</span>
<div class="viewcode-block" id="return_point_density"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.return_point_density">[docs]</a><span class="k">def</span> <span class="nf">return_point_density</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="k">import</span> <span class="n">gaussian</span>
    
    <span class="n">blank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">blank</span><span class="p">[</span><span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">blank</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">blank</span> <span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">blank</span> </div>
    

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Where best to use the baseline_als?</span>
<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="baseline_als"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.baseline_als">[docs]</a><span class="k">def</span> <span class="nf">baseline_als</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">linalg</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">lam</span> <span class="o">*</span> <span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z</span></div>

<span class="c1"># distance based baseline fitting. </span>
<div class="viewcode-block" id="baseline_als_direction"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.baseline_als_direction">[docs]</a><span class="k">def</span> <span class="nf">baseline_als_direction</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">direction_x</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">linalg</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="c1"># # for each y compute the difference</span>
    <span class="c1"># if direction_x == &#39;right&#39;:</span>
    <span class="c1">#     dist = np.abs(lims[1] - y) # pull everything this way. </span>
    <span class="c1"># if direction_x == &#39;left&#39;:</span>
    <span class="c1">#     dist = np.abs( y - lims[0]) # pull everything to the left.    </span>

    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">lam</span> <span class="o">*</span> <span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># mid_z = np.mean(z)</span>
        <span class="k">if</span> <span class="n">direction_x</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
            <span class="n">mid_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">mid_z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">mid_z</span><span class="p">)</span> <span class="c1"># how much to weight this? or just use the median? </span>
        <span class="k">if</span> <span class="n">direction_x</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="n">mid_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">mid_z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">&gt;</span><span class="n">mid_z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z</span></div>

<div class="viewcode-block" id="baseline_als_direction1"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.baseline_als_direction1">[docs]</a><span class="k">def</span> <span class="nf">baseline_als_direction1</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">lims</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">direction_x</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">linalg</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="c1"># # for each y compute the difference</span>
    <span class="c1"># if direction_x == &#39;right&#39;:</span>
    <span class="c1">#     dist = np.abs(lims[1] - y) # pull everything this way. </span>
    <span class="c1"># if direction_x == &#39;left&#39;:</span>
    <span class="c1">#     dist = np.abs( y - lims[0]) # pull everything to the left.    </span>
    
    <span class="c1"># plt.figure()</span>
    <span class="c1"># plt.plot(y, &#39;o&#39;)</span>

    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">lam</span> <span class="o">*</span> <span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># mid_z = np.mean(z)</span>
        <span class="k">if</span> <span class="n">direction_x</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">lims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dists</span><span class="p">))</span>
<span class="c1">#                                print(dists)</span>
<span class="c1">#                                w = p * (z &gt; mid_z) + (1-p) * (z &lt; mid_z) # how much to weight this? or just use the median? </span>
            <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">dists</span> 
        <span class="k">if</span> <span class="n">direction_x</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
<span class="c1">#                                mid_z = np.min(y)</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dists</span><span class="p">))</span>
<span class="c1">#                                print(dists)</span>
<span class="c1">#                                w = p * (z &lt; mid_z) + (1-p) * (z&gt;mid_z)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">dists</span>
            
        <span class="c1"># plt.plot(z, &#39;.&#39;, alpha=0.5)</span>
    <span class="k">return</span> <span class="n">z</span></div>

<div class="viewcode-block" id="generalised_sigmoid"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.generalised_sigmoid">[docs]</a><span class="k">def</span> <span class="nf">generalised_sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sigmoid</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">slope</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">cutoff</span><span class="p">)))</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">shape</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="n">sigmoid</span></div>

<div class="viewcode-block" id="baseline_als_density"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.baseline_als_density">[docs]</a><span class="k">def</span> <span class="nf">baseline_als_density</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">N_cutoff</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instead of the above baseline which moves according the sign of the residual between y and z, we modify to bias towards density instead.</span>
<span class="sd">    suitable for use with (x,y)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">linalg</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>

    <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

    <span class="n">nbrs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">nbrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="p">])</span> <span class="c1"># number of neighbours within the specified radius. </span>

    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">lam</span> <span class="o">*</span> <span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">w</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># w = p * (y &gt; z) + (1-p) * (y &lt; z)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">generalised_sigmoid</span><span class="p">(</span><span class="n">nbrs</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">N_cutoff</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="n">slope</span><span class="p">)</span>
        <span class="c1"># w = p*(nbrs&gt;N_cutoff) + (1-p)*(nbrs&lt;N_cutoff)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">ind</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">ind</span>
    <span class="k">return</span> <span class="n">z</span></div>
    
    
<span class="c1">#def asymmetric_fit(x,y, lam, p, last_state=None, hysteresis=5):</span>
<span class="c1">#    </span>
<span class="c1">#    # determine whether to flip the estimation based on which lies more on either side. </span>
<span class="c1">#    from scipy.stats import linregress</span>
<span class="c1">#    </span>
<span class="c1">#    slope, intercept, r_value, p_value, std_err = linregress(y, x)</span>
<span class="c1">#    </span>
<span class="c1">#    xlinear = y*slope + intercept</span>
<span class="c1">#    </span>
<span class="c1">#    # looks like need to do a polynomial fitting and then determine either side. </span>
<span class="c1">#    n_less = np.sum(x&lt;xlinear)</span>
<span class="c1">#    n_greater = np.sum(x&gt;xlinear)</span>
<span class="c1">#    </span>
<span class="c1">#    if n_greater &gt; n_less + hysteresis:</span>
<span class="c1">#        print &#39;flipping: %d/%d&#39; %(n_less, n_greater)</span>
<span class="c1">#        xfit = baseline_als(-x, lam, p, niter=10)</span>
<span class="c1">#        return -xfit, &#39;flip&#39;</span>
<span class="c1">#    elif n_less &gt; n_greater + hysteresis:</span>
<span class="c1">#        print &#39;no flip: %d/%d&#39; %(n_less, n_greater)</span>
<span class="c1">#        xfit = baseline_als(x, lam, p, niter=10)</span>
<span class="c1">#        return xfit, &#39;no_flip&#39;</span>
<span class="c1">#    else:</span>
<span class="c1">#        if last_state == &#39;flip&#39;:</span>
<span class="c1">#            xfit = baseline_als(-x, lam, p, niter=10)</span>
<span class="c1">#            return -xfit, &#39;flip&#39;</span>
<span class="c1">#        elif last_state == &#39;no_flip&#39;:</span>
<span class="c1">#            xfit = baseline_als(x, lam, p, niter=10)</span>
<span class="c1">#            return xfit, &#39;no_flip&#39;</span>
            
            
<div class="viewcode-block" id="asymmetric_fit"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.asymmetric_fit">[docs]</a><span class="k">def</span> <span class="nf">asymmetric_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flip_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># determine whether to flip the estimation based on which lies more on either side. </span>
    <span class="k">if</span> <span class="n">flip_state</span> <span class="o">==</span> <span class="s1">&#39;flip&#39;</span><span class="p">:</span>
<span class="c1">#        print &#39;flipping: %d/%d&#39; %(n_less, n_greater)</span>
        <span class="n">xfit</span> <span class="o">=</span> <span class="n">baseline_als</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">xfit</span>
    <span class="k">elif</span> <span class="n">flip_state</span> <span class="o">==</span><span class="s1">&#39;no_flip&#39;</span><span class="p">:</span>
        <span class="n">xfit</span> <span class="o">=</span> <span class="n">baseline_als</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xfit</span></div>
    
            
<span class="c1"># def determine_flipping_direction(tracks, thresh=0.5):</span>
    
<span class="c1">#     import numpy as np </span>
<span class="c1">#     diff = tracks[:,1:] - tracks[:,:-1]</span>
<span class="c1">#     diff = np.mean(diff, axis=0) # derive the average movement vector. </span>
    
<span class="c1">#     x_direction_signs = np.sign(diff[:,1])</span>
    
<span class="c1">#     if np.sum(x_direction_signs&lt;0) / float(len(x_direction_signs)) &gt; thresh:</span>
<span class="c1">#         return &#39;flip&#39;</span>
<span class="c1">#     else:</span>
<span class="c1">#         return &#39;no_flip&#39;</span>
<div class="viewcode-block" id="determine_flipping_direction"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.determine_flipping_direction">[docs]</a><span class="k">def</span> <span class="nf">determine_flipping_direction</span><span class="p">(</span><span class="n">tracks_r</span><span class="p">,</span> <span class="n">tracks_g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="c1"># impose a threshold on the movement in order to not bring this in the statistics. ?</span>
    <span class="n">diff_r</span> <span class="o">=</span> <span class="n">tracks_r</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">tracks_r</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">diff_g</span> <span class="o">=</span> <span class="n">tracks_g</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">tracks_g</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">diff_r_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">diff_r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">diff_g_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">diff_g</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff_r_mean</span> <span class="o">+</span> <span class="n">diff_g_mean</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">x_direction_signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">diff</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    
<span class="c1">#    return x_direction_signs</span>
    <span class="n">flip_state</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_direction_signs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">flip_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;flip&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flip_state</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;no_flip&#39;</span><span class="p">)</span>
            
    <span class="n">flip_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">flip_state</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">flip_state</span></div>

        
<span class="c1"># i&#39;m not sure what the curve2stack is doing?</span>
<div class="viewcode-block" id="curve2stack"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.curve2stack">[docs]</a><span class="k">def</span> <span class="nf">curve2stack</span><span class="p">(</span><span class="n">curves</span><span class="p">,</span> <span class="n">yline</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="n">imgs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">:</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">curve</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xline</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">frame</span><span class="p">[</span><span class="n">yline</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">xline</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    
        <span class="n">imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span>
        
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>      </div>


<div class="viewcode-block" id="curve2img"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.curve2img">[docs]</a><span class="k">def</span> <span class="nf">curve2img</span><span class="p">(</span><span class="n">curves</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="n">imgs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">curve</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curves</span><span class="p">):</span>
        <span class="c1"># print ii</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">curve</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">frame</span><span class="p">[</span><span class="n">curve</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">curve</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    
        <span class="n">imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span>
        
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>      </div>
    

<div class="viewcode-block" id="normalize_curves_2D"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.normalize_curves_2D">[docs]</a><span class="k">def</span> <span class="nf">normalize_curves_2D</span><span class="p">(</span><span class="n">curves</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    shape = (m,n) of image. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="n">curve_s</span> <span class="o">=</span> <span class="n">curves</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">curve_s</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">curves</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c1"># normalise the y coordinates.</span>
    <span class="n">curve_s</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">curves</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># normalize the x coordinates.</span>

    <span class="k">return</span> <span class="n">curve_s</span></div>


<div class="viewcode-block" id="uniquefy_curves"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.uniquefy_curves">[docs]</a><span class="k">def</span> <span class="nf">uniquefy_curves</span><span class="p">(</span><span class="n">curves</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    make curves manifold, 1-1 (x,y) mapping (not duply sampled....), where there is duplicates we use mode-seeking behaviour... ?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">uniq_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">curves</span><span class="p">[:,</span><span class="n">axis</span><span class="p">])</span>
    <span class="n">uniq_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curves</span><span class="p">))[</span><span class="n">curves</span><span class="p">[:,</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">xx</span><span class="p">]</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">uniq_x</span><span class="p">]</span>
    <span class="c1"># keep_ids = np.hstack([i for i in uniq_ids if len(i)==1])</span>
    <span class="c1"># mod_ids = [i for i in uniq_ids if len(i)&gt;1]</span>
    <span class="c1"># curve_s = curves[keep_ids]</span>
    <span class="c1"># if len(mod_ids) &gt; 0:</span>
    <span class="c1">#     curve_mod = np.vstack([np.median(curves[ii], axis=0) for ii in mod_ids])</span>
    <span class="c1">#     curve_s = np.vstack([curve_mod, curve_s])</span>
    <span class="c1">#     curve_s = curve_s[np.argsort(curve_s[:,axis])]</span>

    <span class="n">curve_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">uniq_ids</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">curve_s</span></div>


<div class="viewcode-block" id="fit_spline"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.fit_spline">[docs]</a><span class="k">def</span> <span class="nf">fit_spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">UnivariateSpline</span>

    <span class="n">spl</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spl</span></div>
                        

<div class="viewcode-block" id="densify_boundary_line"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.densify_boundary_line">[docs]</a><span class="k">def</span> <span class="nf">densify_boundary_line</span><span class="p">(</span><span class="n">curves</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    curves is a list or numpy array. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">blines</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># </span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="n">c</span> <span class="o">=</span>  <span class="n">c</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">c</span><span class="p">[:,</span><span class="n">axis</span><span class="p">])]</span>
            <span class="n">c_uniq</span> <span class="o">=</span> <span class="n">uniquefy_curves</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">c_uniq</span> <span class="o">=</span> <span class="n">normalize_curves_2D</span><span class="p">(</span><span class="n">c_uniq</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># by chucking this out might have become more unstable? </span>

            <span class="c1"># fit the curves to densify the line... </span>
            <span class="n">spl</span> <span class="o">=</span> <span class="n">fit_spline</span><span class="p">(</span><span class="n">c_uniq</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c_uniq</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="c1"># spl = fit_polyfit(c_uniq[:,0], c_uniq[:,1], degree=2)</span>

            <span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">c</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">c</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">bline_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="c1"># bline_y = np.linspace(0, m, m+1) / float(m)</span>
            <span class="n">bline_x</span> <span class="o">=</span> <span class="n">spl</span><span class="p">(</span><span class="n">bline_y</span><span class="p">)</span> 
            <span class="c1"># bline_y = c_uniq[:,1]</span>
            <span class="c1"># bline_x = eval_boundary_coords(spl, bline_y)[:,0] # evaluate the polynomial fit.</span>

            <span class="n">bline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">bline_x</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">bline_y</span><span class="o">*</span><span class="n">m</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">blines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bline</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">blines</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

    <span class="k">return</span> <span class="n">blines</span></div>


<div class="viewcode-block" id="boundary_roughness"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.boundary_roughness">[docs]</a><span class="k">def</span> <span class="nf">boundary_roughness</span><span class="p">(</span><span class="n">curves_full</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a boundary smoothness term. using l/l_0 </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coefs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curves_full</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="n">l_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> 
            <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="c1"># sum all the individual distances. </span>
            <span class="n">coef</span> <span class="o">=</span> <span class="n">l</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">l_0</span><span class="p">)</span>
            <span class="n">coefs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coefs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="c1"># give a nan to aid in the later informatics. </span>

    <span class="n">coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coefs</span></div>


<div class="viewcode-block" id="boundary_superpixel_coords_RGB"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.boundary_superpixel_coords_RGB">[docs]</a><span class="k">def</span> <span class="nf">boundary_superpixel_coords_RGB</span><span class="p">(</span><span class="n">rgb_video</span><span class="p">,</span> <span class="n">meantracks_r</span><span class="p">,</span> <span class="n">meantracks_g</span><span class="p">,</span> <span class="n">movement_thresh</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">t_av_motion</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">robust</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lenient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">debug_visual</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">y_bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">y_frac_thresh</span><span class="o">=</span><span class="mf">0.60</span><span class="p">):</span>
    
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span>
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">skimage.exposure</span> <span class="k">import</span> <span class="n">rescale_intensity</span>
    <span class="kn">from</span> <span class="nn">Motion_Analysis.tracks_statistics_tools</span> <span class="k">import</span> <span class="n">find_moving_spixels</span><span class="p">,</span> <span class="n">find_const_tracks</span>
    
    <span class="n">n_frames</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rgb_video</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">spixel_size</span> <span class="o">=</span> <span class="n">meantracks_r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">meantracks_r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># spixel size.</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the moving spixels in the meantracks for each colour</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">select_r_track</span> <span class="o">=</span> <span class="n">find_const_tracks</span><span class="p">(</span><span class="n">meantracks_r</span><span class="p">)</span>
    <span class="n">select_g_track</span> <span class="o">=</span> <span class="n">find_const_tracks</span><span class="p">(</span><span class="n">meantracks_g</span><span class="p">)</span>
    
    <span class="n">meantracks_r_</span> <span class="o">=</span> <span class="n">meantracks_r</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">select_r_track</span><span class="p">)]</span>
    <span class="n">meantracks_g_</span> <span class="o">=</span> <span class="n">meantracks_g</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">select_g_track</span><span class="p">)]</span>
                                
    <span class="n">moving_r</span> <span class="o">=</span> <span class="n">find_moving_spixels</span><span class="p">(</span><span class="n">meantracks_r_</span><span class="p">,</span> <span class="n">t_av</span><span class="o">=</span><span class="n">t_av_motion</span><span class="p">,</span> <span class="n">thresh</span> <span class="o">=</span> <span class="n">movement_thresh</span><span class="p">)</span>
    <span class="n">moving_g</span> <span class="o">=</span> <span class="n">find_moving_spixels</span><span class="p">(</span><span class="n">meantracks_g_</span><span class="p">,</span> <span class="n">t_av</span><span class="o">=</span><span class="n">t_av_motion</span><span class="p">,</span> <span class="n">thresh</span> <span class="o">=</span> <span class="n">movement_thresh</span><span class="p">)</span>
    
    <span class="nb">print</span> <span class="n">moving_r</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># if robust==True or lenient==True:</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     flag switches on whether or not we should use asymmetric least squares method to fit the points.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     # flip_state = determine_flipping_direction(np.vstack([meantracks_r, meantracks_g]))</span>
    <span class="c1">#     flip_state = determine_flipping_direction(meantracks_r[moving_r], meantracks_g[moving_g])</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Frame Iteration to determine the boundary curves.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">boundary_curves</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">als_curves</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_frames</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
                    
        <span class="c1"># which superpixels of each colour are moving.</span>
        <span class="n">move_r_frame</span> <span class="o">=</span> <span class="n">moving_r</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span>
        <span class="n">move_g_frame</span> <span class="o">=</span> <span class="n">moving_g</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span>

        <span class="c1"># fetch candidate points. </span>
        <span class="n">pos_r</span> <span class="o">=</span> <span class="n">meantracks_r_</span><span class="p">[</span><span class="n">move_r_frame</span><span class="p">,</span><span class="n">frame</span><span class="p">]</span>
        <span class="n">pos_g</span> <span class="o">=</span> <span class="n">meantracks_g_</span><span class="p">[</span><span class="n">move_g_frame</span><span class="p">,</span><span class="n">frame</span><span class="p">]</span>

        <span class="c1"># print &#39;---&#39;</span>
        <span class="c1"># print move_r_frame.shape</span>

        <span class="c1"># flip_state = determine_flipping_direction(meantracks_r[:,frame:frame+2], meantracks_g[:, frame:frame+2])</span>
        <span class="c1"># print flip_state</span>

        <span class="c1"># if the positions is empty then don&#39;t bother.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_g</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="c1"># find the nearest green and red points that is </span>
            <span class="c1"># how to deal with failures here? </span>
            <span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span> <span class="o">=</span> <span class="n">match_red_green_segs</span><span class="p">(</span><span class="n">pos_r</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">pos_g</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">max_dist</span><span class="o">=</span><span class="n">max_dist</span><span class="o">*</span><span class="n">spixel_size</span><span class="p">,</span> <span class="n">nearest_N</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># coords_r = meantracks_r_[:,frame][:,[1,0]]</span>
            <span class="c1"># coords_g = meantracks_g_[:,frame][:,[1,0]]</span>

            <span class="c1"># # screen out the coords that landed on the side... </span>
            <span class="c1"># coords_r_select = np.logical_and(np.logical_and(coords_r[:,0] &gt; spixel_size, coords_r[:,0] &lt; n-spixel_size), </span>
            <span class="c1">#                                  np.logical_and(coords_r[:,1] &gt; spixel_size, coords_r[:,1] &lt; m-spixel_size))</span>
            <span class="c1"># coords_g_select = np.logical_and(np.logical_and(coords_g[:,0] &gt; spixel_size, coords_g[:,0] &lt; n-spixel_size), </span>
            <span class="c1">#                                  np.logical_and(coords_g[:,1] &gt; spixel_size, coords_g[:,1] &lt; m-spixel_size))</span>
            <span class="c1"># coords_r = coords_r[coords_r_select]</span>
            <span class="c1"># coords_g = coords_g[coords_g_select]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_g</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                
                <span class="n">all_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span><span class="p">])</span>
                <span class="n">test_res</span> <span class="o">=</span> <span class="n">test_y_density</span><span class="p">(</span><span class="n">all_pos</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">y_bins</span><span class="p">,</span> <span class="n">frac_thresh</span><span class="o">=</span><span class="n">y_frac_thresh</span><span class="p">)</span> <span class="c1"># if doesn&#39;t cover at least this fraction of bins then the fitting will be ill-conditioned. </span>
                
                <span class="k">if</span> <span class="n">test_res</span><span class="p">:</span>

                    <span class="n">boundary_curves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_pos</span><span class="p">)</span> <span class="c1"># save all pos out. </span>

                    <span class="c1"># optionally emit the ALS filtered results.</span>
                    <span class="c1"># is there sufficient density ? </span>
                    <span class="c1"># conduct median position filtering </span>
                    <span class="c1"># outlier_select = outlier_detect_axis(all_pos, thresh=2) # this gives numerically better fitting and probably somewhat faster. </span>
                    <span class="c1"># all_pos = all_pos[outlier_select]</span>
                        
                    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Filter the points using ALS algorithm before fitting the boundary curve. </span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    
                    <span class="k">if</span> <span class="n">robust</span><span class="p">:</span>
                        <span class="c1"># print(&#39;robust&#39;)</span>
                        <span class="c1"># x_filt_ALS = asymmetric_fit(all_pos[:,0],all_pos[:,1], lam=1e4, p=0.1, flip_state=flip_state)    </span>
                        <span class="n">x_filt_ALS</span> <span class="o">=</span> <span class="n">baseline_als_density</span><span class="p">(</span><span class="n">all_pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">all_pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="n">e1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="o">*</span><span class="n">spixel_size</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">N_cutoff</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>                                       
                        <span class="n">all_pos_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x_filt_ALS</span><span class="p">,</span> <span class="n">all_pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
                    <span class="k">elif</span> <span class="n">lenient</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;flipping&#39;</span><span class="p">)</span>
                        <span class="c1"># # set the opposite. </span>
                        <span class="c1"># if flip_state ==&#39;flip&#39;:</span>
                        <span class="c1">#     flip_state = &#39;no_flip&#39;</span>
                        <span class="c1"># elif flip_state == &#39;no_flip&#39;:</span>
                        <span class="c1">#     flip_state = &#39;flip&#39;</span>
                        <span class="n">flip</span> <span class="o">=</span> <span class="n">flip_state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="nb">print</span> <span class="n">flip</span> 
                        <span class="n">x_filt_ALS</span> <span class="o">=</span> <span class="n">asymmetric_fit</span><span class="p">(</span><span class="n">all_pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">all_pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="n">e4</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">flip_state</span><span class="o">=</span><span class="n">flip</span><span class="p">)</span>                                            
                        <span class="n">all_pos_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x_filt_ALS</span><span class="p">,</span> <span class="n">all_pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># do nothing more.</span>
                        <span class="n">all_pos_filt</span> <span class="o">=</span> <span class="n">all_pos</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    
                        
                    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Fitting of the final boundary curve :D.  (can we use a more smoothed spline? like a bspline that doesn&#39;t need to pass through all points?)</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="n">als_curves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_pos_filt</span><span class="p">)</span>

                    <span class="c1"># spl_coords = fit_polyfit(all_pos_filt[:,0], all_pos_filt[:,1], degree=2) #use a simple quadratic model to fit. (a lower order might be more preferred.?)</span>
                    <span class="c1"># boundary_curves.append(spl_coords) # just save the model. </span>
                    
                    <span class="c1"># &quot;&quot;&quot;</span>
                    <span class="c1"># Optional Debug Visualization </span>
                    <span class="c1"># &quot;&quot;&quot;</span>
                    <span class="c1"># if debug_visual==True:</span>
                    <span class="c1">#     pos_heatmap = return_point_density(all_pos, (m,n), sigma=spixel_size/2)</span>
                    <span class="c1">#     yline = np.linspace(0, m, 100)</span>
                    <span class="c1">#     b_curve = eval_boundary_coords(spl_coords, yline) # evaluate the polynomial fit.</span>
                        
                    <span class="c1">#     fig, ax = plt.subplots()</span>
                    <span class="c1">#     ax.imshow(rgb_video[frame])</span>
                    <span class="c1">#     ax.imshow(pos_heatmap, cmap=&#39;coolwarm&#39;, alpha=0.3)</span>
                    <span class="c1">#     ax.plot(b_curve[:,0], b_curve[:,1], &#39;w--&#39;, lw=4.)</span>
                    <span class="c1">#     ax.set_xlim([0,n])</span>
                    <span class="c1">#     ax.set_ylim([m,0])</span>
                    <span class="c1">#     plt.show()</span>
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># return no coefficients</span>
                    <span class="n">boundary_curves</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span> <span class="c1"># just save the model. </span>
                    <span class="n">als_curves</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># return no coefficients. </span>
                <span class="n">boundary_curves</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">als_curves</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">boundary_curves</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">als_curves</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>            
    
    <span class="k">return</span> <span class="n">boundary_curves</span><span class="p">,</span> <span class="n">als_curves</span></div>


<div class="viewcode-block" id="boundary_superpixel_meantracks_RGB"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.boundary_superpixel_meantracks_RGB">[docs]</a><span class="k">def</span> <span class="nf">boundary_superpixel_meantracks_RGB</span><span class="p">(</span><span class="n">rgb_video</span><span class="p">,</span> <span class="n">meantracks_r</span><span class="p">,</span> <span class="n">meantracks_g</span><span class="p">,</span> <span class="n">movement_thresh</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">t_av_motion</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">robust</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lenient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">debug_visual</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">y_bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">y_frac_thresh</span><span class="o">=</span><span class="mf">0.60</span><span class="p">):</span>
    
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span>
    <span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">skimage.exposure</span> <span class="k">import</span> <span class="n">rescale_intensity</span>
    <span class="kn">from</span> <span class="nn">Motion_Analysis.tracks_statistics_tools</span> <span class="k">import</span> <span class="n">find_moving_spixels</span><span class="p">,</span> <span class="n">find_const_tracks</span>
    
    <span class="n">n_frames</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rgb_video</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">spixel_size</span> <span class="o">=</span> <span class="n">meantracks_r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">meantracks_r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># spixel size.</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the moving spixels in the meantracks for each colour</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">select_r_track</span> <span class="o">=</span> <span class="n">find_const_tracks</span><span class="p">(</span><span class="n">meantracks_r</span><span class="p">)</span>
    <span class="n">select_g_track</span> <span class="o">=</span> <span class="n">find_const_tracks</span><span class="p">(</span><span class="n">meantracks_g</span><span class="p">)</span>
    
    <span class="n">meantracks_r_</span> <span class="o">=</span> <span class="n">meantracks_r</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">select_r_track</span><span class="p">)]</span>
    <span class="n">meantracks_g_</span> <span class="o">=</span> <span class="n">meantracks_g</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">select_g_track</span><span class="p">)]</span>
                                
    <span class="n">moving_r</span> <span class="o">=</span> <span class="n">find_moving_spixels</span><span class="p">(</span><span class="n">meantracks_r_</span><span class="p">,</span> <span class="n">t_av</span><span class="o">=</span><span class="n">t_av_motion</span><span class="p">,</span> <span class="n">thresh</span> <span class="o">=</span> <span class="n">movement_thresh</span><span class="p">)</span>
    <span class="n">moving_g</span> <span class="o">=</span> <span class="n">find_moving_spixels</span><span class="p">(</span><span class="n">meantracks_g_</span><span class="p">,</span> <span class="n">t_av</span><span class="o">=</span><span class="n">t_av_motion</span><span class="p">,</span> <span class="n">thresh</span> <span class="o">=</span> <span class="n">movement_thresh</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">robust</span><span class="o">==</span><span class="kc">True</span> <span class="ow">or</span> <span class="n">lenient</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        flag switches on whether or not we should use asymmetric least squares method to fit the points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flip_state</span> <span class="o">=</span> <span class="n">determine_flipping_direction</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">meantracks_r</span><span class="p">,</span> <span class="n">meantracks_g</span><span class="p">]))</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Frame Iteration to determine the boundary curves.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">boundary_curves</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)):</span>
                    
        <span class="c1"># which superpixels of each colour are moving.</span>
        <span class="n">move_r_frame</span> <span class="o">=</span> <span class="n">moving_r</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span>
        <span class="n">move_g_frame</span> <span class="o">=</span> <span class="n">moving_g</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span>

        <span class="c1"># fetch candidate points. </span>
        <span class="n">pos_r</span> <span class="o">=</span> <span class="n">meantracks_r_</span><span class="p">[</span><span class="n">move_r_frame</span><span class="p">,</span><span class="n">frame</span><span class="p">]</span>
        <span class="n">pos_g</span> <span class="o">=</span> <span class="n">meantracks_g_</span><span class="p">[</span><span class="n">move_g_frame</span><span class="p">,</span><span class="n">frame</span><span class="p">]</span>

        <span class="c1"># if the positions is empty then don&#39;t bother.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_g</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="c1"># find the nearest green and red points that is </span>
            <span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span> <span class="o">=</span> <span class="n">match_red_green_segs</span><span class="p">(</span><span class="n">pos_r</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">pos_g</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">max_dist</span><span class="o">=</span><span class="n">max_dist</span><span class="o">*</span><span class="n">spixel_size</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_g</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                
                <span class="n">all_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">coords_r</span><span class="p">,</span> <span class="n">coords_g</span><span class="p">])</span>
                <span class="n">test_res</span> <span class="o">=</span> <span class="n">test_y_density</span><span class="p">(</span><span class="n">all_pos</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">y_bins</span><span class="p">,</span> <span class="n">frac_thresh</span><span class="o">=</span><span class="n">y_frac_thresh</span><span class="p">)</span> <span class="c1"># if doesn&#39;t cover at least this fraction of bins then the fitting will be ill-conditioned. </span>
                
                <span class="k">if</span> <span class="n">test_res</span><span class="p">:</span>
                    <span class="c1"># conduct median position filtering </span>
                    <span class="n">outlier_select</span> <span class="o">=</span> <span class="n">outlier_detect_axis</span><span class="p">(</span><span class="n">all_pos</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># this gives numerically better fitting and probably somewhat faster. </span>
                    <span class="n">all_pos</span> <span class="o">=</span> <span class="n">all_pos</span><span class="p">[</span><span class="n">outlier_select</span><span class="p">]</span>
                        
                    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Filter the points using ALS algorithm before fitting the boundary curve. </span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    
                    <span class="k">if</span> <span class="n">robust</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;robust&#39;</span><span class="p">)</span>
                        <span class="n">x_filt_ALS</span> <span class="o">=</span> <span class="n">asymmetric_fit</span><span class="p">(</span><span class="n">all_pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">all_pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="n">e4</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">flip_state</span><span class="o">=</span><span class="n">flip_state</span><span class="p">)</span>                                            
                        <span class="n">all_pos_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x_filt_ALS</span><span class="p">,</span> <span class="n">all_pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
                    <span class="k">elif</span> <span class="n">lenient</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;flipping&#39;</span><span class="p">)</span>
                        <span class="c1"># set the opposite. </span>
                        <span class="k">if</span> <span class="n">flip_state</span> <span class="o">==</span><span class="s1">&#39;flip&#39;</span><span class="p">:</span>
                            <span class="n">flip_state</span> <span class="o">=</span> <span class="s1">&#39;no_flip&#39;</span>
                        <span class="k">elif</span> <span class="n">flip_state</span> <span class="o">==</span> <span class="s1">&#39;no_flip&#39;</span><span class="p">:</span>
                            <span class="n">flip_state</span> <span class="o">=</span> <span class="s1">&#39;flip&#39;</span>
                        <span class="n">x_filt_ALS</span> <span class="o">=</span> <span class="n">asymmetric_fit</span><span class="p">(</span><span class="n">all_pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">all_pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">lam</span><span class="o">=</span><span class="mi">1</span><span class="n">e5</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">flip_state</span><span class="o">=</span><span class="n">flip_state</span><span class="p">)</span>                                            
                        <span class="n">all_pos_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x_filt_ALS</span><span class="p">,</span> <span class="n">all_pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># do nothing more.</span>
                        <span class="n">all_pos_filt</span> <span class="o">=</span> <span class="n">all_pos</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    
                        
                    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Fitting of the final boundary curve :D.  (can we use a more smoothed spline? like a bspline that doesn&#39;t need to pass through all points?)</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="n">spl_coords</span> <span class="o">=</span> <span class="n">fit_polyfit</span><span class="p">(</span><span class="n">all_pos_filt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_pos_filt</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#use a simple quadratic model to fit. (a lower order might be more preferred.?)</span>
                    <span class="n">boundary_curves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spl_coords</span><span class="p">)</span> <span class="c1"># just save the model. </span>
                    
                    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Optional Debug Visualization </span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">debug_visual</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                        <span class="n">pos_heatmap</span> <span class="o">=</span> <span class="n">return_point_density</span><span class="p">(</span><span class="n">all_pos</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">sigma</span><span class="o">=</span><span class="n">spixel_size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">yline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
                        <span class="n">b_curve</span> <span class="o">=</span> <span class="n">eval_boundary_coords</span><span class="p">(</span><span class="n">spl_coords</span><span class="p">,</span> <span class="n">yline</span><span class="p">)</span> <span class="c1"># evaluate the polynomial fit.</span>
                        
                        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rgb_video</span><span class="p">[</span><span class="n">frame</span><span class="p">])</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">pos_heatmap</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">b_curve</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">b_curve</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;w--&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">4.</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">])</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># return no coefficients</span>
                    <span class="n">boundary_curves</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span> <span class="c1"># just save the model. </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># return no coefficients. </span>
                <span class="n">boundary_curves</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">boundary_curves</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assemble the boundary curve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">debug_visual</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Check if we find any curves by seeing if we fit the coefficient or not.</span>
        <span class="n">n_curves</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">boundary_curves</span><span class="p">]</span> <span class="c1"># and we es</span>
    
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">n_curves</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="c1"># Step 1: raster the curves and make into an image. </span>
    <span class="n">yline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c1"># every single y value. (exploiting the integer value nature of y .)</span>
    <span class="n">curves_lines</span> <span class="o">=</span> <span class="n">find_boundary_lines</span><span class="p">(</span><span class="n">boundary_curves</span><span class="p">,</span> <span class="n">yline</span><span class="p">)</span> <span class="c1"># iterate through the boundary spline models and fit the entire y axis to get a value for all possible y&#39;s at every timepoint. </span>
    <span class="n">curve_img</span> <span class="o">=</span> <span class="n">curve2stack</span><span class="p">(</span><span class="n">curves_lines</span><span class="p">,</span> <span class="n">yline</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="n">kymograph_curve_img</span> <span class="o">=</span> <span class="n">curve_img</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">boundary_line</span> <span class="o">=</span> <span class="n">fetch_skeletion_line</span><span class="p">(</span><span class="n">kymograph_curve_img</span><span class="p">,</span> <span class="n">fun</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">)</span> <span class="c1"># use the median which is more robust. </span>
    
<span class="c1">#    if debug_visual==True:</span>
    <span class="n">masked_curve_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">kymograph_curve_img</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kymograph_curve_img</span><span class="p">)</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">kymograph_curve_img</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">rgb_video</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">masked_curve_img</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray_r&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">boundary_line</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">boundary_line</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
        
    <span class="k">return</span> <span class="n">boundary_curves</span><span class="p">,</span> <span class="n">curves_lines</span><span class="p">,</span> <span class="n">curve_img</span><span class="p">,</span> <span class="n">boundary_line</span></div>
   
    

<span class="c1"># =============================================================================</span>
<span class="c1">#   Post-processing and linking of wound boundary tools </span>
<span class="c1"># =============================================================================</span>

<div class="viewcode-block" id="temporal_filter_curves"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.temporal_filter_curves">[docs]</a><span class="k">def</span> <span class="nf">temporal_filter_curves</span><span class="p">(</span><span class="n">curves</span><span class="p">,</span> <span class="n">max_gaps</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the maximum number of frame gaps and impute in the gap given a set of curves. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># first copy the curves object </span>
    <span class="n">curves_</span> <span class="o">=</span> <span class="n">curves</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">curves_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">curves_</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curves</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_frames</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            
    <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find continuous segments:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stretches</span> <span class="o">=</span> <span class="p">[]</span> 
    
    <span class="n">stretch</span> <span class="o">=</span> <span class="p">[</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="c1"># add this in already. </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">time0</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">time1</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">time1</span> <span class="o">-</span> <span class="n">time0</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">stretch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">stretches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stretch</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stretches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stretch</span><span class="p">)</span>
            <span class="n">stretch</span><span class="o">=</span><span class="p">[]</span>

    <span class="n">stretches</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stretches</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stretches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">stretches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">curves</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
<span class="c1">#            print(&#39;nothing to do&#39;)</span>
            <span class="k">return</span> <span class="n">curves</span> <span class="c1"># nothing to be done.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curves_</span><span class="p">[:</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">curves</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="kc">None</span><span class="p">,:]</span> <span class="c1"># just copy this across.</span>
            <span class="k">return</span> <span class="n">curves_</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">stretches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        
<span class="c1">#        print(stretches)</span>
        <span class="c1"># there is more than one segment and we iterate... </span>
        <span class="c1"># 1. fill in before.</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stretches</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="n">seg0</span> <span class="o">=</span> <span class="n">stretches</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">curves_</span><span class="p">[:</span><span class="n">seg0</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">curves</span><span class="p">[</span><span class="n">seg0</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="kc">None</span><span class="p">,:]</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span><span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">stretches</span><span class="p">):</span>
                <span class="n">seg0</span> <span class="o">=</span> <span class="n">stretches</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">seg1</span> <span class="o">=</span> <span class="n">stretches</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        
                <span class="n">curve0</span> <span class="o">=</span> <span class="n">curves</span><span class="p">[</span><span class="n">seg0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">curve1</span> <span class="o">=</span> <span class="n">curves</span><span class="p">[</span><span class="n">seg1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="c1">#                print(&#39;===&#39;)</span>
<span class="c1">#                print(seg0[-1], seg1[0])</span>
<span class="c1">#                print(&#39;***&#39;)</span>
                <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curve0</span><span class="p">)):</span>
                    <span class="n">curves_</span><span class="p">[</span><span class="n">seg0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">seg1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">curve0</span><span class="p">[</span><span class="n">kk</span><span class="p">],</span> <span class="n">curve1</span><span class="p">[</span><span class="n">kk</span><span class="p">],</span> <span class="n">seg1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">seg0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                
        <span class="k">return</span> <span class="n">curves_</span></div>
    

<span class="c1"># =============================================================================</span>
<span class="c1"># boiler scripts to describe the wound boundary to enable plotting for the kymograph.</span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="fetch_coordinates_sections"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.fetch_coordinates_sections">[docs]</a><span class="k">def</span> <span class="nf">fetch_coordinates_sections</span><span class="p">(</span><span class="n">labelled</span><span class="p">):</span>
    
    <span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span> <span class="o">=</span> <span class="n">labelled</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ncols</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows</span><span class="p">))</span>
    
    <span class="n">uniq_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labelled</span><span class="p">)</span>
    
    <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">uniq_regions</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
<span class="c1">#        plt.figure()</span>
<span class="c1">#        plt.imshow(labelled==i)</span>
<span class="c1">#        plt.show()</span>
        <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">[</span><span class="n">labelled</span><span class="o">==</span><span class="n">i</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">labelled</span><span class="o">==</span><span class="n">i</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">coords</span></div>
    
<div class="viewcode-block" id="check_intersect"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.check_intersect">[docs]</a><span class="k">def</span> <span class="nf">check_intersect</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">list_array</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="n">intersect</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_array</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
                <span class="n">intersect</span> <span class="o">=</span> <span class="s1">&#39;yes&#39;</span> <span class="c1"># how long is it ? </span>
<span class="c1">#            elif len(ref) &gt; len(np.intersect1d(ref, item)):</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">intersect</span> <span class="o">=</span> <span class="s1">&#39;add&#39;</span>
                
    <span class="k">if</span> <span class="n">intersect</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">intersect</span> <span class="o">=</span> <span class="s1">&#39;add&#39;</span>

    <span class="k">return</span> <span class="n">intersect</span></div>
     
<div class="viewcode-block" id="find_uniq_merge_groups"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.find_uniq_merge_groups">[docs]</a><span class="k">def</span> <span class="nf">find_uniq_merge_groups</span><span class="p">(</span><span class="n">merge_groups</span><span class="p">):</span>
     
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    
    <span class="n">merge_cand</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">merge_groups</span><span class="p">)</span> <span class="c1"># create a new copy</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merge_cand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">master_merge</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">merge_groups</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">master_merge</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># this only deals with the case when candidates are greater than 1. </span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">merge_cand</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
             <span class="n">cand</span> <span class="o">=</span> <span class="n">merge_cand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># grab the first element.</span>
             <span class="n">merge_cand</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cand</span><span class="p">)</span>
             
             <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merge_cand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                 <span class="c1"># check for intersection with any of the ones already in master merge. </span>
                  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">master_merge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                      <span class="n">master_merge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cand</span><span class="p">)</span>
                  <span class="k">else</span><span class="p">:</span>
                      <span class="n">check</span> <span class="o">=</span> <span class="n">check_intersect</span><span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">master_merge</span><span class="p">)</span>
                      <span class="k">if</span> <span class="n">check</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">check</span> <span class="o">==</span><span class="s1">&#39;add&#39;</span><span class="p">:</span>
                          <span class="n">master_merge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cand</span><span class="p">)</span>
             <span class="k">else</span><span class="p">:</span>
                  <span class="n">merged</span> <span class="o">=</span> <span class="p">[]</span>
                  <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">merge_cand</span><span class="p">:</span>
                       <span class="n">intersect_cand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

                       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersect_cand</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">cand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cand</span><span class="o">+</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
                            <span class="n">cand</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cand</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">cand</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merge_cand</span><span class="p">:</span>
                                <span class="n">merge_cand</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cand</span><span class="p">)</span>
                            <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c1"># remove these.</span>

                  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">master_merge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                      <span class="n">master_merge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cand</span><span class="p">)</span>
                  <span class="k">else</span><span class="p">:</span>
                      <span class="n">check</span> <span class="o">=</span> <span class="n">check_intersect</span><span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">master_merge</span><span class="p">)</span>

                      <span class="k">if</span> <span class="n">check</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">check</span> <span class="o">==</span><span class="s1">&#39;add&#39;</span><span class="p">:</span>
                          <span class="k">if</span> <span class="n">cand</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">master_merge</span><span class="p">:</span>
                              <span class="n">master_merge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cand</span><span class="p">)</span>
                              
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merge_cand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">master_merge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merge_cand</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">master_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">master_merge</span><span class="p">))</span>

    <span class="c1"># final remove of conflicting bits... </span>
    <span class="n">final_filt_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">master_list</span><span class="p">:</span>
        <span class="n">ref_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">master_list</span><span class="p">)</span>
        <span class="n">ref_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">check_intersect</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ref_list</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">overlap</span><span class="o">==</span><span class="s1">&#39;add&#39;</span><span class="p">:</span>
            <span class="n">final_filt_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            
    <span class="n">final_filt_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">final_filt_list</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">final_filt_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">final_filt_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">final_filt_list</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">final_filt_list</span></div>
    
<div class="viewcode-block" id="match_labelled_regions"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.match_labelled_regions">[docs]</a><span class="k">def</span> <span class="nf">match_labelled_regions</span><span class="p">(</span><span class="n">coord_list</span><span class="p">,</span> <span class="n">dist_thresh</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>

    <span class="c1"># this aims to join together random matching elements -&gt; actually there is a more robust method based on gradients! and prediction....    </span>
    <span class="kn">import</span> <span class="nn">itertools</span>
    <span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="k">import</span> <span class="n">pairwise_distances</span>
    
    <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">coord_list</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_list</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord_list</span><span class="p">)),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">coord_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">coord_list</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_dist</span>
        <span class="n">dist_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_dist</span>

    <span class="n">dist_matrix</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1000</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coord_list</span><span class="p">)))</span>
    
    <span class="c1"># now iterate and find all pairs satisfying dist_thresh.</span>
    <span class="n">cands</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)):</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dists</span><span class="p">))[</span><span class="n">dists</span><span class="o">&lt;=</span><span class="n">dist_thresh</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cands</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">select</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">select</span><span class="p">])]])</span>
    
    <span class="c1"># now find all cliques. </span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cands</span> <span class="o">=</span> <span class="n">find_uniq_merge_groups</span><span class="p">(</span><span class="n">cands</span><span class="p">)</span>
<span class="c1">#        print(cands)</span>
        <span class="k">return</span> <span class="n">cands</span></div>
    
    
<div class="viewcode-block" id="fetch_skeletion_line"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.fetch_skeletion_line">[docs]</a><span class="k">def</span> <span class="nf">fetch_skeletion_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">fun</span><span class="p">):</span>
    
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
    <span class="n">binary</span> <span class="o">=</span> <span class="n">img</span> <span class="o">&gt;</span> <span class="mi">0</span>
    
    <span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ncols</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows</span><span class="p">))</span>
    
    <span class="n">X_valid</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">binary</span><span class="p">]</span>
    <span class="n">Y_valid</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">binary</span><span class="p">]</span>
    
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Y_valid</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">y_</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
        <span class="n">x_</span> <span class="o">=</span> <span class="n">X_valid</span><span class="p">[</span><span class="n">Y_valid</span><span class="o">==</span><span class="n">y_</span><span class="p">]</span>
        <span class="n">x_mean</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span>
        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_mean</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>    
    
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">coords</span></div>
    
<span class="c1"># this function produces an equation for each boundary curve to plot on kymograph.</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#   To do: utilise gradient info? and continuity... ideas.    </span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="process_curve_img_multiple"><a class="viewcode-back" href="../../../MOSES.Motion_Analysis.wound_statistics_tools.html#MOSES.Motion_Analysis.wound_statistics_tools.process_curve_img_multiple">[docs]</a><span class="k">def</span> <span class="nf">process_curve_img_multiple</span><span class="p">(</span><span class="n">curve_img</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">dist_thresh</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    
    <span class="c1"># just fit the largest component. ? </span>
    <span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">square</span><span class="p">,</span> <span class="n">binary_closing</span><span class="p">,</span> <span class="n">binary_dilation</span><span class="p">,</span> <span class="n">diamond</span><span class="p">,</span> <span class="n">disk</span>
    <span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="k">import</span> <span class="n">label</span> 
    
    <span class="n">binary</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">curve_img</span><span class="p">,</span> <span class="n">disk</span><span class="p">(</span><span class="n">dilation</span><span class="p">))</span> <span class="c1"># do some dilation to link missing components. </span>
    <span class="n">labelled</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>
    
    <span class="c1"># now get the coordinates belonging to and find components to link. </span>
    <span class="n">labelled_coords</span> <span class="o">=</span> <span class="n">fetch_coordinates_sections</span><span class="p">(</span><span class="n">labelled</span><span class="p">)</span>
    
<span class="c1">#    plt.figure()</span>
<span class="c1">#    plt.plot([len(c) for c in labelled_coords])</span>
<span class="c1">#    plt.show()</span>
    
<span class="c1">#    print labelled_coords</span>
    <span class="n">merge_regions</span> <span class="o">=</span> <span class="n">match_labelled_regions</span><span class="p">(</span><span class="n">labelled_coords</span><span class="p">,</span> <span class="n">dist_thresh</span><span class="o">=</span><span class="n">dist_thresh</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merge_regions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;merging&#39;</span><span class="p">)</span>
        <span class="c1"># then we merge labelled regions. </span>
        <span class="n">labelled_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">labelled</span><span class="p">)</span>
        <span class="n">regions_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labelled</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">merge_regions</span><span class="p">)):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">merge_regions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">labelled_new</span><span class="p">[</span><span class="n">labelled</span><span class="o">==</span><span class="n">regions_old</span><span class="p">[</span><span class="n">mm</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> 

    <span class="k">else</span><span class="p">:</span>
        <span class="n">labelled_new</span> <span class="o">=</span> <span class="n">labelled</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
<span class="c1">#    fig, ax = plt.subplots()</span>
<span class="c1">#    ax.imshow(labelled)</span>
<span class="c1">#    for i in range(len(labelled_coords)):</span>
<span class="c1">#        mean_coords = np.mean(labelled_coords[i], axis=0)</span>
<span class="c1">#        ax.text(mean_coords[0], mean_coords[1], str(i))</span>
<span class="c1">#    ax.set_aspect(&#39;auto&#39;)</span>
<span class="c1">#    plt.show()</span>
    <span class="c1"># having gotten we go ahead to derive the lines ...</span>
            
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">labelled_new</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="n">b_lines</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labelled_new</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">b_line</span> <span class="o">=</span> <span class="n">fetch_skeletion_line</span><span class="p">(</span><span class="n">labelled_new</span><span class="o">==</span><span class="n">reg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">)</span>
        <span class="n">b_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_line</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">b_lines</span></div>
    
    
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Felix Y. Zhou

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'',
              LANGUAGE:'en',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: ''
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>